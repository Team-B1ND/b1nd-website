{"version":3,"file":"static/js/9142.bd8a7ba9.chunk.js","mappings":"2FAAC,WAEA,GAAqB,qBAAVA,MAAX,CAKA,IAAIC,EAAa,CAChB,IAAO,KACP,KAAQ,OACR,GAAM,KACN,GAAM,KACN,MAAS,KAmEVD,MAAME,MAAMC,IAAI,oBAAoB,SAAUC,GAC7CC,EAAcD,EAAIE,QACnB,GA7EA,CAkBA,SAASC,EAAYC,EAAQC,GAC5B,IAAIC,EAAQF,EAAOC,GAGnB,OADWT,MAAMW,KAAKC,KAAKF,IAE1B,IAAK,SACJ,IAAIG,EAAS,CAAC,EACdL,EAAOC,GAAQ,CACdK,QAASJ,EACTG,OAAQA,GAETR,EAAcQ,GACd,MAED,IAAK,QACJ,IAAK,IAAIE,EAAI,EAAGC,EAAIN,EAAMO,OAAQF,EAAIC,EAAGD,IACxCR,EAAYG,EAAOK,GAEpB,MAED,QAGCV,EADIQ,EAASH,EAAMG,SAAWH,EAAMG,OAAS,CAAC,IAIjD,CAOA,SAASR,EAAcC,GACtB,GAAKA,IAAWA,EAAa,IAA7B,CAKA,IAAK,IAAIG,KAAQR,EACZA,EAAWiB,eAAeT,KAC7BH,EAAQG,GAAQR,EAAWQ,IAK7B,IAAK,IAAIA,KAAQH,EACZA,EAAQY,eAAeT,KAAUR,EAAWQ,KAClC,SAATA,EACHJ,EAAcC,EAAc,MAE5BC,EAAYD,EAASG,GAfxB,CAmBD,CAKA,CAlFA,E","sources":["../node_modules/prismjs/plugins/show-invisibles/prism-show-invisibles.js"],"sourcesContent":["(function () {\n\n\tif (typeof Prism === 'undefined') {\n\t\treturn;\n\t}\n\n\n\tvar invisibles = {\n\t\t'tab': /\\t/,\n\t\t'crlf': /\\r\\n/,\n\t\t'lf': /\\n/,\n\t\t'cr': /\\r/,\n\t\t'space': / /\n\t};\n\n\n\t/**\n\t * Handles the recursive calling of `addInvisibles` for one token.\n\t *\n\t * @param {Object|Array} tokens The grammar or array which contains the token.\n\t * @param {string|number} name The name or index of the token in `tokens`.\n\t */\n\tfunction handleToken(tokens, name) {\n\t\tvar value = tokens[name];\n\n\t\tvar type = Prism.util.type(value);\n\t\tswitch (type) {\n\t\t\tcase 'RegExp':\n\t\t\t\tvar inside = {};\n\t\t\t\ttokens[name] = {\n\t\t\t\t\tpattern: value,\n\t\t\t\t\tinside: inside\n\t\t\t\t};\n\t\t\t\taddInvisibles(inside);\n\t\t\t\tbreak;\n\n\t\t\tcase 'Array':\n\t\t\t\tfor (var i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\thandleToken(value, i);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault: // 'Object'\n\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\tvar inside = value.inside || (value.inside = {});\n\t\t\t\taddInvisibles(inside);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Recursively adds patterns to match invisible characters to the given grammar (if not added already).\n\t *\n\t * @param {Object} grammar\n\t */\n\tfunction addInvisibles(grammar) {\n\t\tif (!grammar || grammar['tab']) {\n\t\t\treturn;\n\t\t}\n\n\t\t// assign invisibles here to \"mark\" the grammar in case of self references\n\t\tfor (var name in invisibles) {\n\t\t\tif (invisibles.hasOwnProperty(name)) {\n\t\t\t\tgrammar[name] = invisibles[name];\n\t\t\t}\n\t\t}\n\n\t\t// eslint-disable-next-line no-redeclare\n\t\tfor (var name in grammar) {\n\t\t\tif (grammar.hasOwnProperty(name) && !invisibles[name]) {\n\t\t\t\tif (name === 'rest') {\n\t\t\t\t\taddInvisibles(grammar['rest']);\n\t\t\t\t} else {\n\t\t\t\t\thandleToken(grammar, name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPrism.hooks.add('before-highlight', function (env) {\n\t\taddInvisibles(env.grammar);\n\t});\n}());\n"],"names":["Prism","invisibles","hooks","add","env","addInvisibles","grammar","handleToken","tokens","name","value","util","type","inside","pattern","i","l","length","hasOwnProperty"],"sourceRoot":""}